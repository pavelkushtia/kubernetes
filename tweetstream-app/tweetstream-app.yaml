---
# TweetStream - Complete Twitter-like Application for Kubernetes
# Includes: PostgreSQL, Redis, Kafka, Node.js API, NGINX Frontend, Monitoring

# Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: tweetstream
  labels:
    name: tweetstream

---
# PostgreSQL Primary Database
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres-primary
  namespace: tweetstream
  labels:
    app: postgres
    role: primary
spec:
  serviceName: postgres-primary
  replicas: 1
  selector:
    matchLabels:
      app: postgres
      role: primary
  template:
    metadata:
      labels:
        app: postgres
        role: primary
    spec:
      containers:
      - name: postgres
        image: postgres:15-alpine
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_DB
          value: "tweetstream"
        - name: POSTGRES_USER
          value: "tweetuser"
        - name: POSTGRES_PASSWORD
          value: "tweetpass123"
        - name: PGDATA
          value: "/var/lib/postgresql/data/pgdata"
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
        - name: init-scripts
          mountPath: /docker-entrypoint-initdb.d
        resources:
          requests:
            memory: "512Mi"
            cpu: "100m"
          limits:
            memory: "1Gi"
            cpu: "200m"
        livenessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - tweetuser
            - -d
            - tweetstream
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - tweetuser
            - -d
            - tweetstream
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: init-scripts
        configMap:
          name: postgres-init-scripts
  volumeClaimTemplates:
  - metadata:
      name: postgres-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: local-path
      resources:
        requests:
          storage: 10Gi

---
apiVersion: v1
kind: Service
metadata:
  name: postgres-primary
  namespace: tweetstream
  labels:
    app: postgres
    role: primary
spec:
  ports:
  - port: 5432
    targetPort: 5432
  selector:
    app: postgres
    role: primary

---
# PostgreSQL Initialization Scripts
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-init-scripts
  namespace: tweetstream
data:
  01-schema.sql: |
    -- TweetStream Database Schema
    
    -- Users table
    CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        username VARCHAR(50) UNIQUE NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        display_name VARCHAR(100),
        bio TEXT,
        avatar_url VARCHAR(255),
        followers_count INTEGER DEFAULT 0,
        following_count INTEGER DEFAULT 0,
        tweets_count INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    -- Tweets table
    CREATE TABLE IF NOT EXISTS tweets (
        id SERIAL PRIMARY KEY,
        user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
        content TEXT NOT NULL,
        likes_count INTEGER DEFAULT 0,
        retweets_count INTEGER DEFAULT 0,
        replies_count INTEGER DEFAULT 0,
        parent_tweet_id INTEGER REFERENCES tweets(id) ON DELETE CASCADE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    -- Follows table (user relationships)
    CREATE TABLE IF NOT EXISTS follows (
        id SERIAL PRIMARY KEY,
        follower_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
        following_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(follower_id, following_id)
    );
    
    -- Likes table
    CREATE TABLE IF NOT EXISTS likes (
        id SERIAL PRIMARY KEY,
        user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
        tweet_id INTEGER REFERENCES tweets(id) ON DELETE CASCADE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user_id, tweet_id)
    );
    
    -- Indexes for performance
    CREATE INDEX IF NOT EXISTS idx_tweets_user_id ON tweets(user_id);
    CREATE INDEX IF NOT EXISTS idx_tweets_created_at ON tweets(created_at DESC);
    CREATE INDEX IF NOT EXISTS idx_tweets_parent_id ON tweets(parent_tweet_id);
    CREATE INDEX IF NOT EXISTS idx_follows_follower ON follows(follower_id);
    CREATE INDEX IF NOT EXISTS idx_follows_following ON follows(following_id);
    CREATE INDEX IF NOT EXISTS idx_likes_user_id ON likes(user_id);
    CREATE INDEX IF NOT EXISTS idx_likes_tweet_id ON likes(tweet_id);
    CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
    CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);

  02-sample-data.sql: |
    -- Sample data for TweetStream
    
    -- Insert sample users
    INSERT INTO users (username, email, password_hash, display_name, bio, followers_count, following_count, tweets_count) VALUES
    ('john_doe', 'john@example.com', '$2b$10$hash1', 'John Doe', 'Software developer and coffee enthusiast ‚òï', 150, 89, 42),
    ('jane_smith', 'jane@example.com', '$2b$10$hash2', 'Jane Smith', 'Tech blogger | AI researcher | Cat lover üê±', 320, 156, 78),
    ('tech_guru', 'guru@example.com', '$2b$10$hash3', 'Tech Guru', 'Sharing the latest in technology and innovation üöÄ', 1250, 234, 156),
    ('coffee_lover', 'coffee@example.com', '$2b$10$hash4', 'Coffee Lover', 'Exploring the world one cup at a time ‚òïüåç', 89, 67, 23),
    ('data_scientist', 'data@example.com', '$2b$10$hash5', 'Data Scientist', 'Making sense of data | Python enthusiast üìäüêç', 567, 123, 89)
    ON CONFLICT (username) DO NOTHING;
    
    -- Insert sample tweets
    INSERT INTO tweets (user_id, content, likes_count, retweets_count, replies_count) VALUES
    (1, 'Just deployed my first Kubernetes application! üöÄ #k8s #devops', 15, 3, 2),
    (2, 'Working on some exciting AI research. The future is here! ü§ñ #AI #MachineLearning', 28, 7, 5),
    (3, 'New blog post: "10 Kubernetes Best Practices for Production" - link in bio üìù', 45, 12, 8),
    (1, 'Coffee break time! ‚òï What''s everyone working on today?', 8, 1, 4),
    (4, 'Discovered an amazing new coffee shop downtown. The espresso is incredible! ‚òï‚ú®', 12, 2, 3),
    (5, 'Just finished analyzing a fascinating dataset. Data tells such interesting stories! üìä', 22, 5, 6),
    (2, 'Attending a great tech conference today. So many inspiring talks! üé§ #TechConf2024', 18, 4, 7),
    (3, 'Kubernetes 1.29 is out! Excited to try the new features üéâ #kubernetes', 67, 15, 12),
    (1, 'Late night coding session. Sometimes the best ideas come after midnight üåôüíª', 11, 2, 3),
    (4, 'Sunday morning vibes with a perfect latte art ‚òïüé®', 25, 6, 8)
    ON CONFLICT DO NOTHING;
    
    -- Insert sample follows
    INSERT INTO follows (follower_id, following_id) VALUES
    (1, 2), (1, 3), (1, 4),
    (2, 1), (2, 3), (2, 5),
    (3, 1), (3, 2), (3, 4), (3, 5),
    (4, 1), (4, 2), (4, 3),
    (5, 2), (5, 3)
    ON CONFLICT (follower_id, following_id) DO NOTHING;
    
    -- Insert sample likes
    INSERT INTO likes (user_id, tweet_id) VALUES
    (2, 1), (3, 1), (4, 1),
    (1, 2), (3, 2), (5, 2),
    (1, 3), (2, 3), (4, 3), (5, 3),
    (2, 4), (3, 4), (5, 4),
    (1, 5), (2, 5), (3, 5)
    ON CONFLICT (user_id, tweet_id) DO NOTHING;

---
# Redis Cache
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: tweetstream
  labels:
    app: redis
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
        command: ["redis-server"]
        args: ["--appendonly", "yes", "--maxmemory", "256mb", "--maxmemory-policy", "allkeys-lru"]
        resources:
          requests:
            memory: "128Mi"
            cpu: "50m"
          limits:
            memory: "256Mi"
            cpu: "100m"
        livenessProbe:
          exec:
            command:
            - redis-cli
            - ping
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - redis-cli
            - ping
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: redis-data
          mountPath: /data
      volumes:
      - name: redis-data
        emptyDir: {}

---
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: tweetstream
  labels:
    app: redis
spec:
  ports:
  - port: 6379
    targetPort: 6379
  selector:
    app: redis

---
# Kafka Message Broker (KRaft mode - no Zookeeper needed)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kafka
  namespace: tweetstream
  labels:
    app: kafka
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kafka
  template:
    metadata:
      labels:
        app: kafka
    spec:
      containers:
      - name: kafka
        image: confluentinc/cp-kafka:7.4.0
        ports:
        - containerPort: 9092
        - containerPort: 9093
        command: ['sh', '-c']
        args:
        - |
          # Create KRaft server.properties
          cat > /tmp/server.properties << 'EOF'
          # KRaft mode configuration
          process.roles=broker,controller
          node.id=1
          controller.quorum.voters=1@localhost:9093
          controller.listener.names=CONTROLLER
          listeners=PLAINTEXT://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093
          advertised.listeners=PLAINTEXT://kafka:9092
          listener.security.protocol.map=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT
          
          # Log configuration
          log.dirs=/var/lib/kafka/data
          num.network.threads=3
          num.io.threads=8
          socket.send.buffer.bytes=102400
          socket.receive.buffer.bytes=102400
          socket.request.max.bytes=104857600
          
          # Topic configuration
          num.partitions=1
          num.recovery.threads.per.data.dir=1
          offsets.topic.replication.factor=1
          transaction.state.log.replication.factor=1
          transaction.state.log.min.isr=1
          auto.create.topics.enable=true
          
          # Log retention
          log.retention.hours=168
          log.segment.bytes=1073741824
          log.retention.check.interval.ms=300000
          
          # Group coordinator
          group.initial.rebalance.delay.ms=0
          EOF
          
          # Format storage
          kafka-storage format --config /tmp/server.properties --cluster-id MkU3OEVBNTcwNTJENDM2Qk --ignore-formatted
          
          # Start Kafka
          exec kafka-server-start /tmp/server.properties
        volumeMounts:
        - name: kafka-data
          mountPath: /var/lib/kafka/data
        resources:
          requests:
            memory: "512Mi"
            cpu: "300m"
          limits:
            memory: "1Gi"
            cpu: "800m"
        livenessProbe:
          exec:
            command:
            - sh
            - -c
            - "kafka-broker-api-versions --bootstrap-server localhost:9092"
          initialDelaySeconds: 120
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - sh
            - -c
            - "kafka-broker-api-versions --bootstrap-server localhost:9092"
          initialDelaySeconds: 90
          periodSeconds: 5
      volumes:
      - name: kafka-data
        emptyDir: {}

---
apiVersion: v1
kind: Service
metadata:
  name: kafka
  namespace: tweetstream
  labels:
    app: kafka
spec:
  ports:
  - name: broker
    port: 9092
    targetPort: 9092
  - name: controller
    port: 9093
    targetPort: 9093
  selector:
    app: kafka

---
# TweetStream API ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: tweetstream-api-config
  namespace: tweetstream
data:
  app.js: |
    const express = require('express');
    const { Pool } = require('pg');
    const redis = require('redis');
    const { Kafka } = require('kafkajs');
    const cors = require('cors');
    const helmet = require('helmet');
    const rateLimit = require('express-rate-limit');
    const promClient = require('prom-client');
    
    const app = express();
    const port = 3000;
    
    // Prometheus metrics
    const register = new promClient.Registry();
    promClient.collectDefaultMetrics({ register });
    
    const httpRequestDuration = new promClient.Histogram({
      name: 'http_request_duration_seconds',
      help: 'Duration of HTTP requests in seconds',
      labelNames: ['method', 'route', 'status_code'],
      buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
    });
    
    const activeUsersGauge = new promClient.Gauge({
      name: 'tweetstream_active_users_total',
      help: 'Total number of active users'
    });
    
    const tweetsCounter = new promClient.Counter({
      name: 'tweetstream_tweets_total',
      help: 'Total number of tweets created'
    });
    
    const likesCounter = new promClient.Counter({
      name: 'tweetstream_likes_total',
      help: 'Total number of likes given'
    });
    
    register.registerMetric(httpRequestDuration);
    register.registerMetric(activeUsersGauge);
    register.registerMetric(tweetsCounter);
    register.registerMetric(likesCounter);
    
    // Middleware
    app.use(helmet());
    app.use(cors());
    app.use(express.json());
    
    // Rate limiting
    const limiter = rateLimit({
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100 // limit each IP to 100 requests per windowMs
    });
    app.use(limiter);
    
    // Metrics middleware
    app.use((req, res, next) => {
      const start = Date.now();
      res.on('finish', () => {
        const duration = (Date.now() - start) / 1000;
        httpRequestDuration
          .labels(req.method, req.route?.path || req.path, res.statusCode)
          .observe(duration);
      });
      next();
    });
    
    // Database connection
    const pool = new Pool({
      host: 'postgres-primary',
      port: 5432,
      database: 'tweetstream',
      user: 'tweetuser',
      password: 'tweetpass123',
      max: 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    });
    
    // Redis connection
    const redisClient = redis.createClient({
      host: 'redis',
      port: 6379
    });
    
    redisClient.on('error', (err) => {
      console.error('Redis error:', err);
    });
    
    // Kafka setup - temporarily disabled
    // const kafka = new Kafka({
    //   clientId: 'tweetstream-api',
    //   brokers: ['kafka:9092']
    // });
    
    // const producer = kafka.producer();
    
    // Initialize connections
    async function initializeConnections() {
      try {
        await redisClient.connect();
        // await producer.connect();
        console.log('Connected to Redis');
      } catch (error) {
        console.error('Connection error:', error);
      }
    }
    
    initializeConnections();
    
    // Health check endpoint
    app.get('/health', (req, res) => {
      res.json({ status: 'healthy', timestamp: new Date().toISOString() });
    });
    
    // Metrics endpoint
    app.get('/metrics', async (req, res) => {
      res.set('Content-Type', register.contentType);
      res.end(await register.metrics());
    });
    
    // Get all tweets
    app.get('/api/tweets', async (req, res) => {
      try {
        const cacheKey = 'tweets:all';
        const cached = await redisClient.get(cacheKey);
        
        if (cached) {
          return res.json(JSON.parse(cached));
        }
        
        const result = await pool.query(`
          SELECT t.*, u.username, u.display_name, u.avatar_url
          FROM tweets t
          JOIN users u ON t.user_id = u.id
          WHERE t.parent_tweet_id IS NULL
          ORDER BY t.created_at DESC
          LIMIT 50
        `);
        
        await redisClient.setEx(cacheKey, 60, JSON.stringify(result.rows));
        res.json(result.rows);
      } catch (error) {
        console.error('Error fetching tweets:', error);
        res.status(500).json({ error: 'Internal server error' });
      }
    });
    
    // Create new tweet
    app.post('/api/tweets', async (req, res) => {
      try {
        const { content, user_id } = req.body;
        
        if (!content || !user_id) {
          return res.status(400).json({ error: 'Content and user_id are required' });
        }
        
        const result = await pool.query(
          'INSERT INTO tweets (user_id, content) VALUES ($1, $2) RETURNING *',
          [user_id, content]
        );
        
        const tweet = result.rows[0];
        
        // Publish to Kafka
        // await producer.send({
        //   topic: 'tweets',
        //   messages: [{
        //     key: tweet.id.toString(),
        //     value: JSON.stringify(tweet)
        //   }]
        // });
        
        // Update metrics
        tweetsCounter.inc();
        
        // Clear cache
        await redisClient.del('tweets:all');
        
        res.status(201).json(tweet);
      } catch (error) {
        console.error('Error creating tweet:', error);
        res.status(500).json({ error: 'Internal server error' });
      }
    });
    
    // Like a tweet
    app.post('/api/tweets/:id/like', async (req, res) => {
      try {
        const { id } = req.params;
        const { user_id } = req.body;
        
        if (!user_id) {
          return res.status(400).json({ error: 'user_id is required' });
        }
        
        // Check if already liked
        const existingLike = await pool.query(
          'SELECT id FROM likes WHERE user_id = $1 AND tweet_id = $2',
          [user_id, id]
        );
        
        if (existingLike.rows.length > 0) {
          return res.status(400).json({ error: 'Tweet already liked' });
        }
        
        // Add like
        await pool.query(
          'INSERT INTO likes (user_id, tweet_id) VALUES ($1, $2)',
          [user_id, id]
        );
        
        // Update tweet likes count
        await pool.query(
          'UPDATE tweets SET likes_count = likes_count + 1 WHERE id = $1',
          [id]
        );
        
        // Update metrics
        likesCounter.inc();
        
        // Clear cache
        await redisClient.del('tweets:all');
        
        res.json({ success: true });
      } catch (error) {
        console.error('Error liking tweet:', error);
        res.status(500).json({ error: 'Internal server error' });
      }
    });
    
    // Get users
    app.get('/api/users', async (req, res) => {
      try {
        const result = await pool.query(
          'SELECT id, username, display_name, bio, followers_count, following_count, tweets_count FROM users ORDER BY followers_count DESC LIMIT 20'
        );
        
        // Update active users metric
        activeUsersGauge.set(result.rows.length);
        
        res.json(result.rows);
      } catch (error) {
        console.error('Error fetching users:', error);
        res.status(500).json({ error: 'Internal server error' });
      }
    });
    
    // Get user by ID
    app.get('/api/users/:id', async (req, res) => {
      try {
        const { id } = req.params;
        const result = await pool.query(
          'SELECT id, username, display_name, bio, followers_count, following_count, tweets_count FROM users WHERE id = $1',
          [id]
        );
        
        if (result.rows.length === 0) {
          return res.status(404).json({ error: 'User not found' });
        }
        
        res.json(result.rows[0]);
      } catch (error) {
        console.error('Error fetching user:', error);
        res.status(500).json({ error: 'Internal server error' });
      }
    });
    
    // Get user tweets
    app.get('/api/users/:id/tweets', async (req, res) => {
      try {
        const { id } = req.params;
        const result = await pool.query(`
          SELECT t.*, u.username, u.display_name, u.avatar_url
          FROM tweets t
          JOIN users u ON t.user_id = u.id
          WHERE t.user_id = $1
          ORDER BY t.created_at DESC
          LIMIT 20
        `, [id]);
        
        res.json(result.rows);
      } catch (error) {
        console.error('Error fetching user tweets:', error);
        res.status(500).json({ error: 'Internal server error' });
      }
    });
    
    app.listen(port, '0.0.0.0', () => {
      console.log(`TweetStream API listening on port ${port}`);
    });

  package.json: |
    {
      "name": "tweetstream-api",
      "version": "1.0.0",
      "description": "TweetStream API - Twitter-like social media backend",
      "main": "app.js",
      "scripts": {
        "start": "node app.js",
        "dev": "nodemon app.js"
      },
      "dependencies": {
        "express": "^4.18.2",
        "pg": "^8.11.3",
        "redis": "^4.6.8",
        "kafkajs": "^2.2.4",
        "cors": "^2.8.5",
        "helmet": "^7.0.0",
        "express-rate-limit": "^6.10.0",
        "prom-client": "^14.2.0"
      },
      "keywords": ["twitter", "social-media", "api", "kubernetes"],
      "author": "TweetStream Team",
      "license": "MIT"
    }

---
# TweetStream API Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tweetstream-api
  namespace: tweetstream
  labels:
    app: tweetstream-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: tweetstream-api
  template:
    metadata:
      labels:
        app: tweetstream-api
    spec:
      containers:
      - name: api
        image: node:18-alpine
        ports:
        - containerPort: 3000
        command: ['sh', '-c']
        args:
        - |
          cd /app
          npm install --production
          node app.js
        workingDir: /app
        env:
        - name: NODE_ENV
          value: "production"
        volumeMounts:
        - name: app-code
          mountPath: /app
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 60
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 5
      volumes:
      - name: app-code
        configMap:
          name: tweetstream-api-config

---
apiVersion: v1
kind: Service
metadata:
  name: tweetstream-api
  namespace: tweetstream
  labels:
    app: tweetstream-api
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "3000"
    prometheus.io/path: "/metrics"
spec:
  ports:
  - port: 3000
    targetPort: 3000
    name: http
  selector:
    app: tweetstream-api

---
# TweetStream Frontend ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: tweetstream-frontend-config
  namespace: tweetstream
data:
  index.html: |
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>TweetStream - Twitter Clone</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                background-color: #000;
                color: #fff;
                line-height: 1.6;
            }
            
            .container {
                max-width: 600px;
                margin: 0 auto;
                padding: 20px;
            }
            
            .header {
                text-align: center;
                padding: 20px 0;
                border-bottom: 1px solid #333;
                margin-bottom: 30px;
            }
            
            .header h1 {
                color: #1da1f2;
                font-size: 2.5em;
                margin-bottom: 10px;
            }
            
            .header p {
                color: #8899a6;
                font-size: 1.1em;
            }
            
            .tweet-form {
                background: #192734;
                border-radius: 15px;
                padding: 20px;
                margin-bottom: 30px;
                border: 1px solid #38444d;
            }
            
            .tweet-form h3 {
                margin-bottom: 15px;
                color: #1da1f2;
            }
            
            .form-group {
                margin-bottom: 15px;
            }
            
            .form-group label {
                display: block;
                margin-bottom: 5px;
                color: #8899a6;
            }
            
            .form-group select,
            .form-group textarea {
                width: 100%;
                padding: 12px;
                border: 1px solid #38444d;
                border-radius: 8px;
                background: #000;
                color: #fff;
                font-size: 16px;
                resize: vertical;
            }
            
            .form-group textarea {
                min-height: 100px;
            }
            
            .btn {
                background: #1da1f2;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 25px;
                cursor: pointer;
                font-size: 16px;
                font-weight: bold;
                transition: background-color 0.2s;
            }
            
            .btn:hover {
                background: #1991db;
            }
            
            .btn:disabled {
                background: #38444d;
                cursor: not-allowed;
            }
            
            .tweets-section h3 {
                margin-bottom: 20px;
                color: #1da1f2;
                font-size: 1.5em;
            }
            
            .tweet {
                background: #192734;
                border-radius: 15px;
                padding: 20px;
                margin-bottom: 15px;
                border: 1px solid #38444d;
                transition: border-color 0.2s;
            }
            
            .tweet:hover {
                border-color: #1da1f2;
            }
            
            .tweet-header {
                display: flex;
                align-items: center;
                margin-bottom: 10px;
            }
            
            .tweet-avatar {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: linear-gradient(45deg, #1da1f2, #14171a);
                display: flex;
                align-items: center;
                justify-content: center;
                margin-right: 12px;
                font-weight: bold;
                color: white;
            }
            
            .tweet-user {
                flex: 1;
            }
            
            .tweet-user .name {
                font-weight: bold;
                color: #fff;
            }
            
            .tweet-user .username {
                color: #8899a6;
                font-size: 0.9em;
            }
            
            .tweet-time {
                color: #8899a6;
                font-size: 0.9em;
            }
            
            .tweet-content {
                margin: 15px 0;
                font-size: 1.1em;
                line-height: 1.5;
            }
            
            .tweet-actions {
                display: flex;
                gap: 20px;
                margin-top: 15px;
                padding-top: 15px;
                border-top: 1px solid #38444d;
            }
            
            .tweet-action {
                display: flex;
                align-items: center;
                gap: 5px;
                color: #8899a6;
                cursor: pointer;
                transition: color 0.2s;
            }
            
            .tweet-action:hover {
                color: #1da1f2;
            }
            
            .tweet-action.liked {
                color: #e0245e;
            }
            
            .loading {
                text-align: center;
                padding: 40px;
                color: #8899a6;
            }
            
            .error {
                background: #722f37;
                color: #ff6b7a;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
                border: 1px solid #8b2635;
            }
            
            .success {
                background: #1e3a2e;
                color: #4ade80;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
                border: 1px solid #166534;
            }
            
            .stats {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 15px;
                margin-bottom: 30px;
            }
            
            .stat-card {
                background: #192734;
                border-radius: 10px;
                padding: 15px;
                text-align: center;
                border: 1px solid #38444d;
            }
            
            .stat-number {
                font-size: 1.8em;
                font-weight: bold;
                color: #1da1f2;
            }
            
            .stat-label {
                color: #8899a6;
                font-size: 0.9em;
                margin-top: 5px;
            }
            
            @media (max-width: 768px) {
                .container {
                    padding: 10px;
                }
                
                .header h1 {
                    font-size: 2em;
                }
                
                .tweet-form,
                .tweet {
                    padding: 15px;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>üê¶ TweetStream</h1>
                <p>A Twitter-like social media platform running on Kubernetes</p>
            </div>
            
            <div class="stats" id="stats">
                <div class="stat-card">
                    <div class="stat-number" id="totalTweets">-</div>
                    <div class="stat-label">Total Tweets</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalUsers">-</div>
                    <div class="stat-label">Active Users</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalLikes">-</div>
                    <div class="stat-label">Total Likes</div>
                </div>
            </div>
            
            <div class="tweet-form">
                <h3>‚úçÔ∏è What's happening?</h3>
                <form id="tweetForm">
                    <div class="form-group">
                        <label for="userSelect">Post as:</label>
                        <select id="userSelect" required>
                            <option value="">Select a user...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="tweetContent">Your tweet:</label>
                        <textarea id="tweetContent" placeholder="What's on your mind?" maxlength="280" required></textarea>
                    </div>
                    <button type="submit" class="btn" id="submitBtn">Tweet</button>
                </form>
            </div>
            
            <div class="tweets-section">
                <h3>üì± Latest Tweets</h3>
                <div id="tweetsContainer">
                    <div class="loading">Loading tweets...</div>
                </div>
            </div>
        </div>
        
        <script>
            const API_BASE = '/api';
            let users = [];
            let tweets = [];
            
            // Initialize the app
            async function init() {
                try {
                    await loadUsers();
                    await loadTweets();
                    updateStats();
                    setupEventListeners();
                } catch (error) {
                    console.error('Initialization error:', error);
                    showError('Failed to initialize the application');
                }
            }
            
            // Load users for the dropdown
            async function loadUsers() {
                try {
                    const response = await fetch(`${API_BASE}/users`);
                    if (!response.ok) throw new Error('Failed to load users');
                    
                    users = await response.json();
                    const userSelect = document.getElementById('userSelect');
                    userSelect.innerHTML = '<option value="">Select a user...</option>';
                    
                    users.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user.id;
                        option.textContent = `${user.display_name} (@${user.username})`;
                        userSelect.appendChild(option);
                    });
                } catch (error) {
                    console.error('Error loading users:', error);
                    showError('Failed to load users');
                }
            }
            
            // Load tweets
            async function loadTweets() {
                try {
                    const response = await fetch(`${API_BASE}/tweets`);
                    if (!response.ok) throw new Error('Failed to load tweets');
                    
                    tweets = await response.json();
                    renderTweets();
                } catch (error) {
                    console.error('Error loading tweets:', error);
                    showError('Failed to load tweets');
                }
            }
            
            // Render tweets
            function renderTweets() {
                const container = document.getElementById('tweetsContainer');
                
                if (tweets.length === 0) {
                    container.innerHTML = '<div class="loading">No tweets yet. Be the first to tweet!</div>';
                    return;
                }
                
                container.innerHTML = tweets.map(tweet => `
                    <div class="tweet">
                        <div class="tweet-header">
                            <div class="tweet-avatar">
                                ${tweet.display_name ? tweet.display_name.charAt(0).toUpperCase() : 'U'}
                            </div>
                            <div class="tweet-user">
                                <div class="name">${tweet.display_name || 'Unknown User'}</div>
                                <div class="username">@${tweet.username || 'unknown'}</div>
                            </div>
                            <div class="tweet-time">
                                ${formatTime(tweet.created_at)}
                            </div>
                        </div>
                        <div class="tweet-content">${escapeHtml(tweet.content)}</div>
                        <div class="tweet-actions">
                            <div class="tweet-action" onclick="likeTweet(${tweet.id})">
                                <span>‚ù§Ô∏è</span>
                                <span>${tweet.likes_count || 0}</span>
                            </div>
                            <div class="tweet-action">
                                <span>üîÑ</span>
                                <span>${tweet.retweets_count || 0}</span>
                            </div>
                            <div class="tweet-action">
                                <span>üí¨</span>
                                <span>${tweet.replies_count || 0}</span>
                            </div>
                        </div>
                    </div>
                `).join('');
            }
            
            // Update statistics
            function updateStats() {
                const totalTweets = tweets.length;
                const totalUsers = users.length;
                const totalLikes = tweets.reduce((sum, tweet) => sum + (tweet.likes_count || 0), 0);
                
                document.getElementById('totalTweets').textContent = totalTweets;
                document.getElementById('totalUsers').textContent = totalUsers;
                document.getElementById('totalLikes').textContent = totalLikes;
            }
            
            // Setup event listeners
            function setupEventListeners() {
                const tweetForm = document.getElementById('tweetForm');
                tweetForm.addEventListener('submit', handleTweetSubmit);
                
                // Auto-refresh tweets every 30 seconds
                setInterval(async () => {
                    await loadTweets();
                    updateStats();
                }, 30000);
            }
            
            // Handle tweet submission
            async function handleTweetSubmit(e) {
                e.preventDefault();
                
                const userSelect = document.getElementById('userSelect');
                const tweetContent = document.getElementById('tweetContent');
                const submitBtn = document.getElementById('submitBtn');
                
                const userId = userSelect.value;
                const content = tweetContent.value.trim();
                
                if (!userId || !content) {
                    showError('Please select a user and enter tweet content');
                    return;
                }
                
                submitBtn.disabled = true;
                submitBtn.textContent = 'Tweeting...';
                
                try {
                    const response = await fetch(`${API_BASE}/tweets`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            user_id: parseInt(userId),
                            content: content
                        })
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to create tweet');
                    }
                    
                    showSuccess('Tweet posted successfully!');
                    tweetContent.value = '';
                    await loadTweets();
                    updateStats();
                    
                } catch (error) {
                    console.error('Error creating tweet:', error);
                    showError(error.message || 'Failed to post tweet');
                } finally {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Tweet';
                }
            }
            
            // Like a tweet
            async function likeTweet(tweetId) {
                const userSelect = document.getElementById('userSelect');
                const userId = userSelect.value;
                
                if (!userId) {
                    showError('Please select a user first');
                    return;
                }
                
                try {
                    const response = await fetch(`${API_BASE}/tweets/${tweetId}/like`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            user_id: parseInt(userId)
                        })
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to like tweet');
                    }
                    
                    await loadTweets();
                    updateStats();
                    
                } catch (error) {
                    console.error('Error liking tweet:', error);
                    if (error.message !== 'Tweet already liked') {
                        showError(error.message || 'Failed to like tweet');
                    }
                }
            }
            
            // Utility functions
            function formatTime(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();
                const diff = now - date;
                
                if (diff < 60000) return 'now';
                if (diff < 3600000) return `${Math.floor(diff / 60000)}m`;
                if (diff < 86400000) return `${Math.floor(diff / 3600000)}h`;
                return date.toLocaleDateString();
            }
            
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            function showError(message) {
                const container = document.querySelector('.container');
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message;
                container.insertBefore(errorDiv, container.firstChild);
                
                setTimeout(() => {
                    errorDiv.remove();
                }, 5000);
            }
            
            function showSuccess(message) {
                const container = document.querySelector('.container');
                const successDiv = document.createElement('div');
                successDiv.className = 'success';
                successDiv.textContent = message;
                container.insertBefore(successDiv, container.firstChild);
                
                setTimeout(() => {
                    successDiv.remove();
                }, 3000);
            }
            
            // Initialize the app when the page loads
            document.addEventListener('DOMContentLoaded', init);
        </script>
    </body>
    </html>

  nginx.conf: |
    events {
        worker_connections 1024;
    }
    
    http {
        include       /etc/nginx/mime.types;
        default_type  application/octet-stream;
        
        log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                        '$status $body_bytes_sent "$http_referer" '
                        '"$http_user_agent" "$http_x_forwarded_for"';
        
        access_log /var/log/nginx/access.log main;
        error_log /var/log/nginx/error.log warn;
        
        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;
        keepalive_timeout 65;
        types_hash_max_size 2048;
        
        gzip on;
        gzip_vary on;
        gzip_min_length 1024;
        gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;
        
        server {
            listen 80;
            server_name _;
            
            root /usr/share/nginx/html;
            index index.html;
            
            # Serve static files
            location / {
                try_files $uri $uri/ /index.html;
                add_header Cache-Control "public, max-age=3600";
            }
            
            # Proxy API requests
            location /api/ {
                proxy_pass http://tweetstream-api:3000;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                
                # CORS headers
                add_header Access-Control-Allow-Origin *;
                add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
                add_header Access-Control-Allow-Headers "Content-Type, Authorization";
                
                if ($request_method = 'OPTIONS') {
                    return 204;
                }
            }
            
            # Health check
            location /health {
                access_log off;
                return 200 "healthy\n";
                add_header Content-Type text/plain;
            }
        }
    }

---
# TweetStream Frontend Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tweetstream-frontend
  namespace: tweetstream
  labels:
    app: tweetstream-frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: tweetstream-frontend
  template:
    metadata:
      labels:
        app: tweetstream-frontend
    spec:
      containers:
      - name: nginx
        image: nginx:1.25-alpine
        ports:
        - containerPort: 80
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
        - name: html-content
          mountPath: /usr/share/nginx/html/index.html
          subPath: index.html
        resources:
          requests:
            memory: "128Mi"
            cpu: "50m"
          limits:
            memory: "256Mi"
            cpu: "100m"
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: nginx-config
        configMap:
          name: tweetstream-frontend-config
      - name: html-content
        configMap:
          name: tweetstream-frontend-config

---
apiVersion: v1
kind: Service
metadata:
  name: tweetstream-frontend
  namespace: tweetstream
  labels:
    app: tweetstream-frontend
spec:
  ports:
  - port: 80
    targetPort: 80
  selector:
    app: tweetstream-frontend

---
# Ingress for TweetStream
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: tweetstream-ingress
  namespace: tweetstream
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
spec:
  ingressClassName: nginx
  rules:
  - host: tweetstream.192.168.1.82.nip.io
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: tweetstream-frontend
            port:
              number: 80

---
# Horizontal Pod Autoscaler for API
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: tweetstream-api-hpa
  namespace: tweetstream
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: tweetstream-api
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80

---
# Horizontal Pod Autoscaler for Frontend
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: tweetstream-frontend-hpa
  namespace: tweetstream
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: tweetstream-frontend
  minReplicas: 2
  maxReplicas: 5
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70

---
# ServiceMonitor for API metrics
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: tweetstream-api-metrics
  namespace: tweetstream
  labels:
    app: tweetstream-api
spec:
  selector:
    matchLabels:
      app: tweetstream-api
  endpoints:
  - port: http
    path: /metrics
    interval: 30s

---
# ServiceMonitor for PostgreSQL exporter
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: postgres-exporter-metrics
  namespace: tweetstream
  labels:
    app: postgres-exporter
spec:
  selector:
    matchLabels:
      app: postgres-exporter
  endpoints:
  - port: metrics
    path: /metrics
    interval: 30s

---
# ServiceMonitor for Redis exporter
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: redis-exporter-metrics
  namespace: tweetstream
  labels:
    app: redis-exporter
spec:
  selector:
    matchLabels:
      app: redis-exporter
  endpoints:
  - port: metrics
    path: /metrics
    interval: 30s

---
# ServiceMonitor for Kafka exporter
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: kafka-exporter-metrics
  namespace: tweetstream
  labels:
    app: kafka-exporter
spec:
  selector:
    matchLabels:
      app: kafka-exporter
  endpoints:
  - port: metrics
    path: /metrics
    interval: 30s 